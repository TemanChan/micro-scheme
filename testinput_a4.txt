(lambda (x y z) (* x y z))
(define multiply (lambda (x y z) (* x y z)))
(define multiply-tracing (lambda (x y z) (print (quote multiplying..)) (* x y z)))
((lambda (x y) (+ x y)) 2 3)
(multiply 2 3 4)
(multiply-tracing 2 3 4)
(apply multiply (quote (2 3 4)))
(define apply-to-2-3-4 (lambda (f) (apply f (quote (2 3 4)))))
(apply-to-2-3-4 multiply)
(define foo (lambda () (print (quote Hello)) (print (quote world)) (print (quote !!))))
(foo)
(define z 3)
((lambda (x) (+ x z)) 2)
(define x 4)
((lambda (x) (+ x z)) 2)
(define factorial (lambda (x) (if (< x 2) 1 (* x (factorial (- x 1))))))
(factorial 1)
(factorial 4)
(factorial 10)
(define > (lambda (x y) (< y x)))
(> 2 5)
(define >= (lambda (x y) (not (< x y))))
(>= 3 2)
(define <= (lambda (x y) (not (< y x))))
(<= 3 3)
(define = (lambda (x y) (if (< x y) 0 (not (< y x)))))
(= 2 2)
(= 2 3)
(= 3 2)
(define abs (lambda (x) (if (< x 0) (- 0 x) x)))
(abs 3)
(abs -3)
((lambda (x y) (* x y)) 2 3)
(let ((x 2) (y 3)) (* x y))
(define for-each (lambda (func list) (if (nullp list) (quote ()) ((lambda () (func (car list)) (for-each func (cdr list)))))))
(define square (lambda (x) (print (* x x))))
(for-each square (quote (2 5 9 14 256)))
(define first (lambda args (car args)))
(first (quote a) (quote b) (quote c))
(first (quote a) (quote b) (quote c) (quote d) (quote e) (quote f))
